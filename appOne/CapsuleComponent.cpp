#include "CapsuleComponent.h"
#include "CharacterActor.h"
#include "mathUtil.h"
#include "Game.h"
#include "SEGMENT.h"
#include "ActorManager.h"

CapsuleComponent::CapsuleComponent(CharacterActor* owner)
	: SpriteComponent(owner)
	, mAmbient(0.0f)
	, mNumCAng(24)
	, mNumCVtx(0)
	, mCOp(nullptr)
	, mBright(nullptr)
	, mSegP(nullptr)
	, mSOp(nullptr)
	, mSegRadius(0.0005f)
	, mNumSAng(4)
	, mNumSVtx(0)
	, mSeg(nullptr)
	, mPos(0.0f, 0.0f, 0.0f)
	, mIsCollision(true)
{
	SetUp();
	createSegment();
	createCapsule();
	mOwner->GetGame()->GetActorManager()->AddCapsule(this);
}

CapsuleComponent::~CapsuleComponent()
{
	delete[] mCOp;
	delete[] mBright;
	delete[] mSOp;
	delete[] mSegP;
	delete[] mCapP;
	delete mSeg;

	while (!mNotCollisionTags.empty())
	{
		mNotCollisionTags.pop_back();
	}

	mOwner->GetGame()->GetActorManager()->RemoveCapsule(this);
}

int CapsuleComponent::SetUp()
{
	mNumCVtx = mNumCAng * (mNumCAng / 2) + 2;
	mNumSVtx = mNumSAng * 2;
	mCOp = new VECTOR[mNumCVtx];
	mBright = new float[mNumCVtx];
	mSegP = new VECTOR[mNumSVtx];
	mSOp = new VECTOR[mNumSVtx];
	mCapP = new VECTOR[mNumCVtx];
	mSeg = new SEGMENT;
	mLightPos = mOwner->GetGame()->GetAllData()->rendererData.mLightPos;
	mAmbient = mOwner->GetGame()->GetAllData()->rendererData.mAmbient;
	return 1;
}

void CapsuleComponent::Update()
{
	auto owner = static_cast<CharacterActor*>(mOwner);
	mPos = owner->GetPosition() + owner->GetCapsulOffset();
	VECTOR osp = VECTOR(0.0f, 0.0f, 0.0f);
	VECTOR oep = VECTOR(0.0f, 0.0f, 0.0f);

	if (mOEp.x == 0.0f && mOEp.y == 0.0f && mOEp.z == 0.0f)
	{
		mOEp = oep;
	}
	if (mOSp.x == 0.0f && mOSp.y == 0.0f && mOSp.z == 0.0f)
	{
		mOSp = osp;
	}

	mSeg->update(mPos, owner->GetRotation(), mOSp, mOEp);

	for (auto capsule : mOwner->GetGame()->GetActorManager()->GetCapsules())
	{
		auto capOwner = static_cast<CharacterActor*>(capsule->GetOwner());

		bool isNotCollision = false;

		for (auto tags : mNotCollisionTags)
		{
			if (static_cast<CharacterActor::CharactersTag>(tags) == capOwner->GetTag())
			{
				isNotCollision = true;
			}
		}

		if (capsule == this || isNotCollision || capOwner->GetHp() <= 0)
		{
			continue;
		}


		VECTOR mp1;
		VECTOR mp2;
		float t1;
		float t2;
		float dist = 0;

		dist = calcSegmentSegmentDist(mSeg, capsule->GetSegment(), mp1, mp2, t1, t2);
		if (mIsCollision && capsule->IsCollision() && dist < owner->GetRadius() + static_cast<CharacterActor*>(capsule->GetOwner())->GetRadius())
		{
			capsule->GetOwner()->SetPosition(capsule->GetOwner()->GetPosition() + (mp2 - mp1).normalize() * 0.05f);
			if (capsule->GetOwner()->GetPosition().y < 0.0f && capsule->GetOwner()->PositionOnMap(capsule->GetOwner()->GetPosition(), static_cast<CharacterActor*>(capsule->GetOwner())->GetRadius()))
			{
				capsule->GetOwner()->SetPosition(capsule->GetOwner()->GetPosition().x, 0.0f, capsule->GetOwner()->GetPosition().z);
			}
		}
	}
}

void CapsuleComponent::Draw()
{
	auto owner = static_cast<CharacterActor*>(mOwner);

	segment(mSeg->GetSP(), mSeg->GetEP(), COLOR(255, 255, 255), 100);
	capsule(mPos, owner->GetRotation(), mCapsuleColor, mOSp.y, mOEp.y, owner->GetRadius());
}

bool CapsuleComponent::OverlapSegment(SEGMENT* s1, SEGMENT* s2, float radius1, float radius2)
{
	VECTOR mp1;
	VECTOR mp2;
	float t1;
	float t2;
	float dist = 0;

	dist = calcSegmentSegmentDist(s1, s2, mp1, mp2, t1, t2);

	if (dist < radius1 + radius2)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool CapsuleComponent::OverlapActor(class CharacterActor* a1, class CharacterActor* a2)
{
	auto seg1 = a1->GetCapsule()->GetSegment();
	auto seg2 = a2->GetCapsule()->GetSegment();

	VECTOR a1Pos = a1->GetPosition() + a1->GetCapsulOffset();
	VECTOR a2Pos = a2->GetPosition() + a2->GetCapsulOffset();

	seg1->update(a1Pos, a1->GetRotation(), a1->GetCapsule()->GetOSp(), a1->GetCapsule()->GetOEp());
	seg2->update(a2Pos, a2->GetRotation(), a2->GetCapsule()->GetOSp(), a2->GetCapsule()->GetOEp());

	return OverlapSegment(seg1, seg2, a1->GetRadius(), a2->GetRadius());
}

bool CapsuleComponent::LineTraceHitActor(class SEGMENT* seg, CharacterActor** Actor, VECTOR* hitPos)
{
	auto owner = static_cast<CharacterActor*>(mOwner);
	VECTOR pos = owner->GetPosition() + owner->GetCapsulOffset();
	seg->update(pos, owner->GetRotation());

	bool flag = false;

	for (auto chara : owner->GetGame()->GetActorManager()->GetCharacters())
	{
		if (chara == owner || (!chara->GetCapsule() || chara->GetCategory() == CharacterActor::Object))
		{
			continue;
		}

		auto Cseg = chara->GetCapsule()->GetSegment();
		Cseg->update(chara->GetPosition() + chara->GetCapsulOffset(), chara->GetRotation(), chara->GetCapsule()->GetOSp(), chara->GetCapsule()->GetOEp());
		VECTOR mp1;
		VECTOR mp2;
		float t1;
		float t2;
		float dist = 0;

		dist = calcSegmentSegmentDist(Cseg, seg, mp1, mp2, t1, t2);

		if ((0.1f + chara->GetRadius()) > dist)
		{
			seg->SetEP(seg->GetSP() + seg->GetV() * t2);
			flag = true;
			*Actor = chara;
			*hitPos = seg->GetEP();
			break;
		}
	}

	return flag;
}

void CapsuleComponent::createSegment()
{
	//å¥ì_Ç©ÇÁâEÇ÷êLÇ—ÇÈäpíåÇçÏÇÈ
	float angle = 3.1415926f / (mNumSAng / 2);
	for (int j = 0; j < 2; j++) {
		for (int i = 0; i < mNumSAng; i++) {
			mSOp[mNumSAng * j + i].x = mOpX[j];
			mSOp[mNumSAng * j + i].y = Cos(angle * i) * mSegRadius;
			mSOp[mNumSAng * j + i].z = Sin(angle * i) * mSegRadius;
		}
	}
}

void CapsuleComponent::segment(const VECTOR& sp, const VECTOR& ep, const COLOR& col, float thickness)
{
	VECTOR* p = new VECTOR[mNumSVtx];
	VECTOR v = ep - sp;
	float len = v.mag();
	float angleY = Atan2(-v.z, v.x);
	v.normalize();
	float angleZ = Acos(-v.y) - 1.57f;
	gWorld.identity();
	gWorld.mulTranslate(sp.x, sp.y, sp.z);
	gWorld.mulRotateY(angleY);
	gWorld.mulRotateZ(angleZ);
	gWorld.mulScaling(len, thickness, thickness);
	for (int i = 0; i < mNumSVtx; i++) {
		p[i] = gWorld * mSOp[i];
		p[i] = mOwner->GetGame()->GetRenderer()->GetView() * p[i];
		p[i] = mOwner->GetGame()->GetRenderer()->GetProj() * p[i];
	}
	//ï`âÊ
	for (int i = 0; i < mNumSAng; i++) {
		//ë§ñ Ç≈Ç†ÇÈéläpå`
		int a = i;
		int b = i + mNumSAng;
		int c = (i + 1) % mNumSAng == 0 ? i + 1 - mNumSAng : i + 1;
		int d = (b + 1) % mNumSAng == 0 ? b + 1 - mNumSAng : b + 1;
		triangle3D(p[a], p[b], p[c], col, col, col);
		triangle3D(p[c], p[b], p[d], col, col, col);
	}

	delete[]p;
}

void CapsuleComponent::createCapsule()
{
	VECTOR light = mLightPos;
	light.normalize();
	float radius = 0.2f;
	float angle = 3.1415926f / (mNumCAng / 2);
	int j, k = 0;
	//ñkã…Ç…Ç»ÇÈí∏ì_
	mCOp[k].set(0, 1, 0);
	mBright[k] = dot(light, mCOp[k]);
	if (mBright[k] < mAmbient)mBright[k] = mAmbient;
	k++;
	//è„îºãÖ
	for (j = 0; j < (mNumCAng / 4); j++) {
		float y = Cos(angle * (j + 1));
		float r = Sin(angle * (j + 1));
		//â~ÇÃç¿ïW
		for (int i = 0; i < mNumCAng; i++) {
			mCOp[k].set(Cos(angle * i) * r, y, Sin(angle * i) * r);
			//op[k]Çñ@ê¸Ç∆ÇµÇƒí∏ì_ÇÃñæÇÈÇ≥ÇåvéZ
			mBright[k] = dot(light, mCOp[k]);
			if (mBright[k] < mAmbient)mBright[k] = mAmbient;
			k++;
		}
	}
	//â∫îºãÖ
	for (j -= 1; j < (mNumCAng / 2) - 1; j++) {
		float y = Cos(angle * (j + 1));
		float r = Sin(angle * (j + 1));
		//â~ÇÃç¿ïW
		for (int i = 0; i < mNumCAng; i++) {
			mCOp[k].set(Cos(angle * i) * r, y, Sin(angle * i) * r);
			//op[k]Çñ@ê¸Ç∆ÇµÇƒí∏ì_ÇÃñæÇÈÇ≥ÇåvéZ
			mBright[k] = dot(light, mCOp[k]);
			if (mBright[k] < mAmbient)mBright[k] = mAmbient;
			k++;
		}
	}
	//ìÏã…Ç…Ç»ÇÈí∏ì_
	mCOp[k].set(0, -1, 0);
	mBright[k] = dot(light, mCOp[k]);
	if (mBright[k] < mAmbient)mBright[k] = mAmbient;
}
void CapsuleComponent::capsule(const VECTOR& t, const VECTOR& r,
	const COLOR& col, float segStartPos, float segEndPos, float radius)
{
	//è„îºãÖ
	MATRIX world;
	world.identity();
	world.mulTranslate(t);
	world.mulRotateYXZ(r);
	world.mulTranslate(0, segStartPos, 0);
	world.mulScaling(radius, radius, radius);
	for (int i = 0; i < mNumCVtx / 2; i++) {
		mCapP[i] = world * mCOp[i];
		mCapP[i] = mOwner->GetGame()->GetRenderer()->GetView() * mCapP[i];
		mCapP[i] = mOwner->GetGame()->GetRenderer()->GetProj() * mCapP[i];
	}
	//â∫îºãÖ
	world.identity();
	world.mulTranslate(t);
	world.mulRotateYXZ(r);
	world.mulTranslate(0, segEndPos, 0);
	world.mulScaling(radius, radius, radius);
	for (int i = mNumCVtx / 2; i < mNumCVtx; i++) {
		mCapP[i] = world * mCOp[i];
		mCapP[i] = mOwner->GetGame()->GetRenderer()->GetView() * mCapP[i];
		mCapP[i] = mOwner->GetGame()->GetRenderer()->GetProj() * mCapP[i];
	}
	//ï`âÊ
	//è„äWìIÇ»ñ ÇÕéOäpå`Ç≈ï`âÊ
	for (int i = 0; i < mNumCAng; i++) {
		int a = 0;
		int b = i + 1;
		int c = (i + 1) % mNumCAng == 0 ? i + 2 - mNumCAng : i + 2;
		VECTOR m = mCapP[b] - mCapP[a];
		VECTOR n = mCapP[c] - mCapP[a];
		//if (m.x * n.y - m.y * n.x <= 0)
		{
			triangle3D(mCapP[a], mCapP[b], mCapP[c], col * mBright[a], col * mBright[b], col * mBright[c]);
			//	print("p(" + (let)p[a].x + "," + (let)p[a].y + "," + (let)p[a].z + ")");
		}
	}
	//ë§ñ ìIÇ»ñ ÇÕéläpå`Ç≈ï`âÊ
	for (int i = 0; i < mNumCVtx - mNumCAng - 2; i++) {
		int a = i + 1;
		int b = a + mNumCAng;
		int c = (i + 1) % mNumCAng == 0 ? b + 1 - mNumCAng : b + 1;
		int d = (i + 1) % mNumCAng == 0 ? a + 1 - mNumCAng : a + 1;
		VECTOR m = mCapP[b] - mCapP[a];
		VECTOR n = mCapP[c] - mCapP[a];
		//if (m.x * n.y - m.y * n.x <= 0)
		//{
		triangle3D(mCapP[a], mCapP[b], mCapP[c], col * mBright[a], col * mBright[b], col * mBright[c]);
		triangle3D(mCapP[a], mCapP[c], mCapP[d], col * mBright[a], col * mBright[c], col * mBright[d]);
		//print("p(" + (let)p[a].x + "," + (let)p[a].y + "," + (let)p[a].z + ")");
	//}
	}
	////â∫äWìIÇ»ñ ÇÕéOäpå`Ç≈ï`âÊ
	for (int i = mNumCVtx - mNumCAng - 1; i < mNumCVtx - 1; i++) {
		int a = mNumCVtx - 1;
		int b = i;
		int c = i % mNumCAng == 0 ? i + 1 - mNumCAng : i + 1;
		VECTOR m = mCapP[b] - mCapP[a];
		VECTOR n = mCapP[c] - mCapP[a];
		//if (m.x * n.y - m.y * n.x >= 0)
		{
			triangle3D(mCapP[a], mCapP[b], mCapP[c], col * mBright[a], col * mBright[b], col * mBright[c]);
		}
	}

	/*for (int i = 0; i < mNumCVtx - 1; i++)
	{
		print("cop[" + (let)i + "](" + (let)mCOp[i].x + "," + (let)mCOp[i].y + "," + (let)mCOp[i].z + ")");
	}*/
	//print("Chimpo");
}

//ì_Ç∆íºê¸ÇÃç≈íZãóó£
float CapsuleComponent::calcPointLineDist //ç≈íZãóó£
(
	const VECTOR& p, //ì_ 
	SEGMENT* s, //ê¸ï™Åiíºê¸àµÇ¢Åj
	VECTOR& mp, //ì_pÇ©ÇÁíºê¸Ç…â∫ÇÎÇµÇΩêÇê¸ÇÃí[ì_
	float& t //s.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus.spÇ©ÇÁmpÇ‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
)
{
	t = 0.0f;
	float dvv = s->GetV().magSq();//dot(s.v, s.v)Ç∆ìØÇ∂
	if (dvv > 0.0f) {
		t = dot(s->GetV(), p - s->GetSP()) / dvv;
		// è„ÇÃéÆÇÃê‡ñæ
		// dot(s.v, p-s.sp) ÇÕ |s.v||p-s.sp|cosÉ¶
		// dvvÇÕ|s.v|ÇÃÇQèÊ
		// è„ÇÃåvéZÇ≈ÅAtÇÕ |p-s.sp|cosÉ¶ / |s.v|Ç∆Ç»ÇÈÅB
		// Ç¬Ç‹ÇËtÇÕÅudotÇ≈ìäâeÇµÇΩí∑Ç≥ÅÄs.vÇÃí∑Ç≥ÅvÇ∆Ç¢Ç§äÑçáÇ…Ç»ÇÈ
	}
	mp = s->GetSP() + s->GetV() * t;
	return (p - mp).mag();
}

//ì_Ç∆ê¸ï™ÇÃç≈íZãóó£
float CapsuleComponent::calcPointSegmentDist//ç≈íZãóó£
(
	const VECTOR& p, //ì_
	SEGMENT* s, //ê¸ï™
	VECTOR& mp, //ì_pÇ©ÇÁê¸ï™Ç‹Ç≈ÇÃç≈íZãóó£Ç∆Ç»ÇÈì_(énì_Ç‚èIì_Ç…Ç»ÇÈÇ±Ç∆Ç‡Ç†ÇÈ)
	float& t //s.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus.spÇ©ÇÁmpÇ‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
)
{
	//Ç∆ÇËÇ†Ç¶Ç∏ì_Ç©ÇÁíºê¸Ç‹Ç≈ÇÃç≈íZãóó£Ç‚mp,tÇãÅÇﬂÇƒÇ›ÇÈ
	float dist = calcPointLineDist(p, s, mp, t);
	//mpÇ™ê¸ï™ÇÃäOÇ…Ç†ÇÈ(énì_äÒÇË)
	if (t < 0.0f) {
		//ì_Ç©ÇÁê¸ï™ÇÃénì_Ç‹Ç≈ÇÃãóó£Ç™ç≈íZ
		mp = s->GetSP();
		return (p - mp).mag();
	}
	//mpÇ™ê¸ï™ÇÃäOÇ…Ç†ÇÈ(èIì_äÒÇË)
	if (t > 1.0f) {
		//ì_Ç©ÇÁê¸ï™ÇÃèIì_Ç‹Ç≈ÇÃãóó£Ç™ç≈íZ
		mp = s->GetEP();
		return(p - mp).mag();
	}
	//mpÇ™ê¸ï™ì‡Ç…Ç†ÇÈ
	//0 <= t <= 1
	return dist;
}

//íºê¸Ç∆íºê¸ÇÃç≈íZãóó£
float CapsuleComponent::calcLineLineDist
(
	SEGMENT* s1,//íºê¸ÇP
	SEGMENT* s2,//íºê¸ÇQ
	VECTOR& mp1, //ç≈íZê¸ÇÃí[ì_ÇP
	VECTOR& mp2, //ç≈íZê¸ÇÃí[ì_ÇQ
	float& t1, //s1.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus1.spÇ©ÇÁmp1Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
	float& t2  //s2.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus2.spÇ©ÇÁmp2Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
)
{
	//2íºê¸Ç™ïΩçs
	if (cross(s1->GetV(), s2->GetV()).magSq() < 0.000001f) {
		//ê¸ï™1ÇÃénì_Ç©ÇÁíºê¸2Ç‹Ç≈ÇÃç≈íZãóó£ñ‚ëËÇ…ãAíÖÇ∑ÇÈ
		t1 = 0.0f;
		mp1 = s1->GetSP();
		float dist = calcPointLineDist(mp1, s2, mp2, t2);
		return dist;
	}

	float dv1v2 = dot(s1->GetV(), s2->GetV());
	float dv1v1 = s1->GetV().magSq();//dot(s1.v,s1.v)Ç∆ìØÇ∂
	float dv2v2 = s2->GetV().magSq();//dot(s2.v,s2.v)Ç∆ìØÇ∂
	VECTOR vp2p1 = s1->GetSP() - s2->GetSP();
	t1 = (dv1v2 * dot(s2->GetV(), vp2p1) - dv2v2 * dot(s1->GetV(), vp2p1))
		/ (dv1v1 * dv2v2 - dv1v2 * dv1v2);
	mp1 = s1->GetSP() + s1->GetV() * t1;
	t2 = dot(s2->GetV(), mp1 - s2->GetSP()) / dv2v2;
	mp2 = s2->GetSP() + s2->GetV() * t2;
	return (mp2 - mp1).mag();
}

//2ê¸ï™ä‘ÇÃç≈íZãóó£
float CapsuleComponent::calcSegmentSegmentDist
(
	SEGMENT* s1,//ê¸ï™1
	SEGMENT* s2,//ê¸ï™2
	VECTOR& mp1, //ç≈íZê¸ÇÃí[ì_1(énì_Ç‚èIì_Ç…Ç»ÇÈÇ±Ç∆Ç‡Ç†ÇÈ)
	VECTOR& mp2, //ç≈íZê¸ÇÃí[ì_2(énì_Ç‚èIì_Ç…Ç»ÇÈÇ±Ç∆Ç‡Ç†ÇÈ)
	float& t1, //s1.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus1.spÇ©ÇÁmp1Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
	float& t2  //s2.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus2.spÇ©ÇÁmp2Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
)
{
	float dist = 0;
	{
		// s1.vÇ™èkëﬁÇµÇƒÇ¢ÇÈÅH
		if (s1->GetV().magSq() < 0.000001f) {
			// s2.vÇ‡èkëﬁÅH
			if (s2->GetV().magSq() < 0.000001f) {
				// ì_Ç∆ì_ÇÃãóó£ÇÃñ‚ëËÇ…ãAíÖ
				dist = (s2->GetSP() - s1->GetSP()).mag();
				mp1 = s1->GetSP();
				mp2 = s2->GetSP();
				t1 = t2 = 0.0f;
				//segment(mp1, mp2, COLOR(255, 255, 255), 10);
				return dist;
			}
			else {
				// s1.spÇ∆s2.vÇÃç≈íZñ‚ëËÇ…ãAíÖ
				dist = calcPointSegmentDist(s1->GetSP(), s2, mp2, t2);
				mp1 = s1->GetSP();
				t1 = 0.0f;
				clamp0to1(t2);
				//segment(mp1, mp2, COLOR(255, 255, 255), 10);
				return dist;
			}
		}
		// s2.vÇ™èkëﬁÇµÇƒÇ¢ÇÈÅH
		else if (s2->GetV().magSq() < 0.000001f) {
			// s2.spÇ∆sv1ÇÃç≈íZñ‚ëËÇ…ãAíÖ
			float dist = calcPointSegmentDist(s2->GetSP(), s1, mp1, t1);
			mp2 = s2->GetSP();
			clamp0to1(t1);
			t2 = 0.0f;
			//segment(mp1, mp2, COLOR(255, 255, 255), 10);
			return dist;
		}
	}

	//----------------------------------------------------------------
	//Ç∆ÇËÇ†Ç¶Ç∏2íºê¸ä‘ÇÃç≈íZãóó£,mp1,mp2,t1,t2ÇãÅÇﬂÇƒÇ›ÇÈ
	dist = calcLineLineDist(s1, s2, mp1, mp2, t1, t2);
	if (0.0f <= t1 && t1 <= 1.0f &&
		0.0f <= t2 && t2 <= 1.0f) {
		//mp1,mp2Ç™óºï˚Ç∆Ç‡ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		return dist;
	}
	//mp1,mp2ÇÃóºï˚ÅAÇ‹ÇΩÇÕÇ«ÇøÇÁÇ©Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//----------------------------------------------------------------
	//mp1,t1ÇãÅÇﬂíºÇ∑ ÅÀ t2Ç0Å`1Ç…ÉNÉâÉìÉvÇµÇƒmp2Ç©ÇÁs1.vÇ…êÇê¸Çç~ÇÎÇµÇƒÇ›ÇÈ
	clamp0to1(t2);
	mp2 = s2->GetSP() + s2->GetV() * t2;
	dist = calcPointLineDist(mp2, s1, mp1, t1);
	if (0.0f <= t1 && t1 <= 1.0f) {
		//mp1Ç™ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		return dist;
	}
	//mp1Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//----------------------------------------------------------------
	//mp2,t2ÇãÅÇﬂíºÇ∑ ÅÀ t1Ç0Å`1Ç…ÉNÉâÉìÉvÇµÇƒmp1Ç©ÇÁs2.vÇ…êÇê¸Çç~ÇÎÇµÇƒÇ›ÇÈ
	clamp0to1(t1);
	mp1 = s1->GetSP() + s1->GetV() * t1;
	dist = calcPointLineDist(mp1, s2, mp2, t2);
	if (0.0f <= t2 && t2 <= 1.0f) {
		//mp2Ç™ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		return dist;
	}
	//mp2Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//----------------------------------------------------------------
	//t2ÇÉNÉâÉìÉvÇµÇƒmp2ÇçƒåvéZÇ∑ÇÈÇ∆ÅAmp1Ç©ÇÁmp2Ç‹Ç≈Ç™ç≈íZ
	clamp0to1(t2);
	mp2 = s2->GetSP() + s2->GetV() * t2;
	return (mp2 - mp1).mag();
}

//ï‚èïê¸ÉoÅ[ÉWÉáÉì
COLOR Yellow(255, 255, 0);
COLOR Red(255, 0, 0);
COLOR Green(0, 255, 0);
COLOR Cyan(0, 255, 255);
float CapsuleComponent::calcSegmentSegmentDist_
(
	SEGMENT* s1,//ê¸ï™1
	SEGMENT* s2,//ê¸ï™2
	VECTOR& mp1, //ç≈íZê¸ÇÃí[ì_1(énì_Ç‚èIì_Ç…Ç»ÇÈÇ±Ç∆Ç‡Ç†ÇÈ)
	VECTOR& mp2, //ç≈íZê¸ÇÃí[ì_2(énì_Ç‚èIì_Ç…Ç»ÇÈÇ±Ç∆Ç‡Ç†ÇÈ)
	float& t1, //s1.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus1.spÇ©ÇÁmp1Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
	float& t2 //s2.vÇÃí∑Ç≥Ç1Ç∆ÇµÇΩéûÇÃÅus2.spÇ©ÇÁmp2Ç‹Ç≈ÇÃí∑Ç≥ÅvÇÃäÑçá
)
{
	//íºê¸Ç…å©ÇπÇÈÇΩÇﬂÇÃï‚èïê¸
	segment(s1->GetSP() - s1->GetV() * 3, s1->GetEP() + s1->GetV() * 3, COLOR(90, 90, 90), 2);
	segment(s2->GetSP() - s2->GetV() * 3, s2->GetEP() + s2->GetV() * 3, COLOR(90, 90, 90), 2);

	float dist = 0;

	//------------------------------------------------------------------------
	//check1:Ç∆ÇËÇ†Ç¶Ç∏2íºê¸ä‘ÇÃç≈íZãóó£,mp1,mp2,t1,t2ÇãÅÇﬂÇƒÇ›ÇÈ
	dist = calcLineLineDist(s1, s2, mp1, mp2, t1, t2);
	fill(Yellow);
	if (0.0f <= t1 && t1 <= 1.0f &&
		0.0f <= t2 && t2 <= 1.0f) {
		//mp1,mp2Ç™óºï˚Ç∆Ç‡ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		print((let)"check1ÅZÅFt1=" + t1 + " t2=" + t2);
		segment(mp1, mp2, Yellow, 10);
		point(mp1, Yellow, 30);
		point(mp2, Yellow, 30);
		return dist;
		//return 0;

	}
	print((let)"check1Å~ÅFt1=" + t1 + " t2=" + t2);
	segment(mp1, mp2, Yellow, 2);
	point(mp2, Yellow, 12);
	point(mp1, Yellow, 12);
	//mp1,mp2ÇÃóºï˚ÅAÇ‹ÇΩÇÕÇ«ÇøÇÁÇ©Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//------------------------------------------------------------------------
	//check2:mp1,t1ÇãÅÇﬂíºÇ∑ ÅÀ t2Ç0Å`1Ç…ÉNÉâÉìÉvÇµÇƒmp2Ç©ÇÁs1.vÇ…êÇê¸Çç~ÇÎÇµÇƒÇ›ÇÈ
	clamp0to1(t2);
	mp2 = s2->GetSP() + s2->GetV() * t2;
	dist = calcPointLineDist(mp2, s1, mp1, t1);
	fill(Red);
	if (0.0f <= t1 && t1 <= 1.0f) {
		//mp1Ç™ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		print((let)"check2ÅZÅFt1=" + t1 + " t2=" + t2);
		segment(mp1, mp2, Red, 10);
		point(mp1, Red, 30);
		return dist;
		//return 0;

	}
	print((let)"check2Å~ÅFt1=" + t1 + " t2=" + t2);
	segment(mp1, mp2, Red, 2);
	point(mp1, Red, 12);
	//mp1Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//------------------------------------------------------------------------
	//check3:mp2,t2ÇãÅÇﬂíºÇ∑ ÅÀ t1Ç0Å`1Ç…ÉNÉâÉìÉvÇµÇƒmp1Ç©ÇÁs2.vÇ…êÇê¸Çç~ÇÎÇµÇƒÇ›ÇÈ
	clamp0to1(t1);
	mp1 = s1->GetSP() + s1->GetV() * t1;
	dist = calcPointLineDist(mp1, s2, mp2, t2);
	fill(Green);
	if (0.0f <= t2 && t2 <= 1.0f) {
		//mp2Ç™ê¸ï™ì‡Ç…Ç†Ç¡ÇΩ
		print((let)"check3ÅZÅFt1=" + t1 + " t2=" + t2);
		segment(mp1, mp2, Green, 10);
		point(mp2, Green, 30);
		return dist;
		//return 0;
	}
	print((let)"check3Å~ÅFt1=" + t1 + " t2=" + t2);
	segment(mp1, mp2, Green, 2);
	point(mp2, Green, 12);
	//mp2Ç™ê¸ï™ì‡Ç…Ç»Ç©Ç¡ÇΩÇÃÇ≈éüÇ÷

	//-----------------------------------------------------------------------
	clamp0to1(t2);
	mp2 = s2->GetSP() + s2->GetV() * t2;
	fill(Cyan);
	print((let)"last  Å@ÅFt1=" + t1 + " t2=" + t2);
	segment(mp1, mp2, COLOR(Cyan), 10);
	//Ç±Ç±Ç‹Ç≈óàÇΩÇÁÅAmp1Ç©ÇÁmp2Ç‹Ç≈Ç™ç≈íZ
	return (mp2 - mp1).mag();
}
